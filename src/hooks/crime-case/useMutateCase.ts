import { useMutation, useQueryClient } from '@tanstack/react-query';
import {
  createCrimeCaseTransaction,
  updateCrimeCaseTransaction,
  deleteCrimeCaseTransaction,
} from '@/server/queries/crime';
import useSupabaseBrowser from '@/server/supabase/client';
import {
  CrimeCaseData,
  LocationData,
  PersonData,
  CrimeCaseTransactionResult,
} from '@/types/crime-case';
import type { TypedSupabaseClient } from '@/types/supabase-client';
import toast from 'react-hot-toast';

const CRIME_CASE_IMAGE_BUCKET = 'crime-case-images';
const CRIME_CASE_IMAGE_PREFIX = 'crime-cases';

const sanitizeFileName = (name: string) =>
  name.replace(/[^a-zA-Z0-9._-]/g, '_');

const buildImagePath = (file: File) => {
  const safeName = sanitizeFileName(file.name);
  const uniqueId =
    globalThis.crypto?.randomUUID?.() ??
    `${Date.now()}-${Math.random().toString(16).slice(2)}`;

  return `${CRIME_CASE_IMAGE_PREFIX}/${uniqueId}-${safeName}`;
};

async function uploadCaseImages(
  supabase: TypedSupabaseClient,
  files: File[],
): Promise<string[]> {
  if (!files.length) {
    return [];
  }

  const bucket = supabase.storage.from(CRIME_CASE_IMAGE_BUCKET);
  const uploadedKeys: string[] = [];

  for (const file of files) {
    const path = buildImagePath(file);
    const { error } = await bucket.upload(path, file, {
      contentType: file.type || undefined,
      upsert: false,
    });

    if (error) {
      if (uploadedKeys.length > 0) {
        await bucket.remove(uploadedKeys);
      }
      throw new Error(error.message || 'Failed to upload crime case image');
    }

    uploadedKeys.push(path);
  }

  return uploadedKeys;
}

async function cleanupUploadedImages(
  supabase: TypedSupabaseClient,
  keys: string[],
) {
  if (keys.length === 0) {
    return;
  }

  await supabase.storage.from(CRIME_CASE_IMAGE_BUCKET).remove(keys);
}

// Separate input types for each operation
type CreateCrimeCaseInput = {
  crimeCase: CrimeCaseData;
  location: LocationData;
  persons: PersonData[];
  imageFiles?: File[];
};

type UpdateCrimeCaseInput = {
  id: number;
  crimeCase: CrimeCaseData;
  location: LocationData;
  persons: PersonData[];
  imageFiles?: File[];
  existingImageKeys?: string[];
};
// CREATE HOOK
export function useCreateCrimeCase() {
  const supabase = useSupabaseBrowser();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      crimeCase,
      location,
      persons,
      imageFiles,
    }: CreateCrimeCaseInput): Promise<CrimeCaseTransactionResult> => {
      if (!supabase) {
        throw new Error('Database connection error. Please try again.');
      }

      const uploadedImageKeys = await uploadCaseImages(
        supabase,
        imageFiles ?? [],
      );

      // Note: case_number is auto-generated by the database RPC function
      // from the primary key ID and incident year (format: CASE-YYYY-NNNN)
      const { data, error } = await createCrimeCaseTransaction(
        supabase,
        {
          ...crimeCase,
          image_keys: uploadedImageKeys,
        },
        location,
        persons,
      );

      if (error) {
        await cleanupUploadedImages(supabase, uploadedImageKeys);
        throw new Error(error.message || 'Failed to create crime case');
      }

      const payload = data as CrimeCaseTransactionResult | null;

      if (!payload || payload.success === false) {
        await cleanupUploadedImages(supabase, uploadedImageKeys);
        throw new Error(
          payload?.error || payload?.message || 'Failed to create crime case',
        );
      }

      console.log('Create result:', payload);

      return payload;
    },
    onMutate: () => {
      toast.loading('Creating crime case...', { id: 'create-crime-case' });
    },
    onSuccess: (payload) => {
      toast.dismiss('create-crime-case');
      toast.success(payload.message || 'Crime case created successfully!');

      queryClient.invalidateQueries({ queryKey: ['crime-cases'] });

      console.log('Crime case create successful:', payload);
    },
    onError: (error) => {
      toast.dismiss('create-crime-case');

      if (error instanceof Error) {
        const msg = error.message.toLowerCase();

        if (msg.includes('permission')) {
          toast.error("You don't have permission to create crime cases.");
        } else if (msg.includes('network')) {
          toast.error('Network error. Please check your connection and try again.');
        } else if (msg.includes('validation') || msg.includes('invalid')) {
          toast.error('The case data is invalid. Please review the form and try again.');
        } else {
          toast.error(error.message || 'Failed to create crime case');
        }
      } else {
        toast.error('An unexpected error occurred while creating the crime case.');
      }

      console.error('Crime case create error:', error);
    },
    retry: (failureCount, error) => {
      if (error instanceof Error && error.message.includes('network')) {
        return failureCount < 2;
      }
      return false;
    },
  });
}

// UPDATE HOOK
export function useUpdateCrimeCase() {
  const supabase = useSupabaseBrowser();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      id,
      crimeCase,
      location,
      persons,
      imageFiles,
      existingImageKeys,
    }: UpdateCrimeCaseInput): Promise<CrimeCaseTransactionResult> => {
      if (!supabase) {
        throw new Error('Database connection error. Please try again.');
      }

      const uploadedImageKeys = await uploadCaseImages(
        supabase,
        imageFiles ?? [],
      );
      const mergedImageKeys = [
        ...(existingImageKeys ?? []),
        ...uploadedImageKeys,
      ];

      const { data, error } = await updateCrimeCaseTransaction(
        supabase,
        id,
        {
          ...crimeCase,
          image_keys: mergedImageKeys,
        },
        location,
        persons,
      );

      if (error) {
        await cleanupUploadedImages(supabase, uploadedImageKeys);
        throw new Error(error.message || 'Failed to update crime case');
      }

      const payload = data as CrimeCaseTransactionResult | null;

      if (!payload || payload.success === false) {
        await cleanupUploadedImages(supabase, uploadedImageKeys);
        throw new Error(
          payload?.error || payload?.message || 'Failed to update crime case',
        );
      }

      console.log('Update result:', payload);

      return payload;
    },
    onMutate: () => {
      toast.loading('Updating crime case...', { id: 'update-crime-case' });
    },
    onSuccess: (payload) => {
      toast.dismiss('update-crime-case');
      toast.success(payload.message || 'Crime case updated successfully!');

      queryClient.invalidateQueries({ queryKey: ['crime-cases'] });
      queryClient.invalidateQueries({ queryKey: ['crime-case'] });

      console.log('Crime case update successful:', payload);
    },
    onError: (error) => {
      toast.dismiss('update-crime-case');

      if (error instanceof Error) {
        const msg = error.message.toLowerCase();

        if (msg.includes('permission')) {
          toast.error("You don't have permission to update this crime case.");
        } else if (msg.includes('network')) {
          toast.error('Network error. Please check your connection and try again.');
        } else if (msg.includes('not found')) {
          toast.error('This crime case no longer exists.');
        } else if (msg.includes('validation') || msg.includes('invalid')) {
          toast.error('The case data is invalid. Please review the form and try again.');
        } else {
          toast.error(error.message || 'Failed to update crime case');
        }
      } else {
        toast.error('An unexpected error occurred while updating the crime case.');
      }

      console.error('Crime case update error:', error);
    },
    retry: (failureCount, error) => {
      if (error instanceof Error && error.message.includes('network')) {
        return failureCount < 2;
      }
      return false;
    },
  });
}

// DELETE HOOK
export function useDeleteCrimeCase() {
  const supabase = useSupabaseBrowser();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ id }: { id: number }) => {
      if (!supabase) {
        throw new Error('Database connection error. Please try again.');
      }

      const result = await deleteCrimeCaseTransaction(supabase, id);

      if (!result || result.error) {
        throw new Error(result?.error?.message || 'Failed to delete crime case');
      }

      return result;
    },
    onMutate: () => {
      toast.loading('Deleting crime case...', { id: 'delete-crime-case' });
    },
    onSuccess: (data) => {
      toast.dismiss('delete-crime-case');
      toast.success('Crime case deleted successfully!');
      
      queryClient.invalidateQueries({ queryKey: ['crime-cases'] });
      queryClient.invalidateQueries({ queryKey: ['crime-case'] });
      
      console.log('Crime case delete successful:', data);
    },
    onError: (error) => {
      toast.dismiss('delete-crime-case');
      
      if (error instanceof Error) {
        const errorMessage = error.message;
        
        if (errorMessage.includes('permission')) {
          toast.error("You don't have permission to perform this action");
        } else if (errorMessage.includes('network')) {
          toast.error('Network error. Please check your connection and try again.');
        } else if (errorMessage.includes('foreign key')) {
          toast.error('Cannot delete: This case has related records');
        } else {
          toast.error(`Failed to delete crime case: ${errorMessage}`);
        }
      } else {
        toast.error('An unexpected error occurred. Please try again.');
      }
      
      console.error('Crime case delete error:', error);
    },
    retry: (failureCount, error) => {
      if (error instanceof Error && error.message.includes('network')) {
        return failureCount < 2;
      }
      return false;
    },
  });
}
